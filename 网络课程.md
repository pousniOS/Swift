# linux网络编程课程介绍

1. linux网络编程之TCP/IP基础篇
2. linux网络编程之socket编程遍
3. linux网络编程之线程篇
4. linux网络编程之实战篇(miniftpd实现)

# 第一章
## ISO/OSI参考模型
### OSI（open system interconnection）开放系统互联模型是由ISO（international Organization for standardization）国际化标准组织定义的网络分层模型，共七层。   

1. ISO/OSI的七层网络模型    

| 主机A|| 主机B||传输的单位|
|:----:|:----:|:----:|:----:|:----:|
|应用层|<---应用层协议--->|应用层|提供应用程序间通信|apud|
|表示层|<---表示层协议--->|表示层|处理数据格式、数据加密等|ppud|
|会话层|<---会话层协议--->|会话层|建立、维护和管理回话|supd|
|传输层|<---传输层协议--->|传输层|建立端到端连接|segment|
|网络层|<---网络层协议--->|网络层|寻址和路由器选择|packet|
|数据链路层|<---链路层协议--->|数据链路层|介质访问，链路管理|frame|
|物理层|<---物理层协议--->|物理层|比特流传输|bit|

2. 不同层次的功能特性

+ 物理层（physical layer）：物理层定义了所有电子及物理设备的规范，为上层的传输层提供了一个物理介质，本层中数据传输的单位为bit。属于本层定义的规范有EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等，实际使用的设备如网卡等属于本层。

+ 数据链路层（data link layer）：对物理层收到的bit数据进行数据成帧。提供可靠的数据传输服务，实现无差距数据传输。在数据链路层中数据的单位为帧（frame）。属于本层定义的规范有SDLC、HDLC、PPP、STP、帧中继等，实际使用的设备如switch交换机属于本层。

+ 网络层（network layer）：网络层负责将各个子网之间的数据进行路由选择，分组与重组。本层中数据传输的单位为数据包（packet）。属于本层协议规范有IP、IPX、OSPF、ICMP、IGMP等。实际使用的设备如路由器属于本层。

+ 传输层（transport layer）：提供可靠的数据传输服务，它检测路由器丢弃的包，然后产生一个重传请求，能够将乱序收到的数据包重新排序。

+ 会话层（session layer）：管理主机之间回话过程，包括会话建立、终止和会话过程中的管理。

+ 表示层（Presentation layer）：表示层对网络传输的数据进行交换，使得多个主机之间传输的信息可以相互理解，包括数据的压缩、加密、格式转换等。

+ 应用层（application layer）：应用层与应用程序界面沟通，以达至展示给用户的目的，再次常见的有：HTTP、HTTPS、FTP、TELNET、SSH、SMTP、POP3等。

## TCP/IP四层模型

### 理想七层模型和实际四层模型对应关系

|七层模型|四层模型|重要的协议|
|:----:|:----:|:----:|
|应用层application layer<br>表示层presentation layer<br>会话层Session layer|应用层application layer|HTTP、HTTPS、FTP|
|传输层 transport layer<br>|传输层transport layer|TCP、UDP|
|网络层 internet layer|网络层 internet layer|ICMP、IP、IGMP|
|数据链路层 data link layer<br>物理层physical layer|链路层 link layer|ARP、RARP|

## 基本概念(对等通信、封装、分用、端口)
### 对等通信
1. 主机之间同一层级之间的通信称之为对等通信
2. 虚电路：一个客户端软件跟服务器软件进行通信我们就好像是双方建立了一个连接
3. 真实的数据流是：客应用层->客传输层->网络层->链路层->主链路层->网络层->传输层->应用层
4. 对等层传输的数据我们可以把他看做是逻辑流

### 封装（encapsulation）
1. 数据封装流程    

|步骤：||
|:----:|:----:|
|第一步|{用户数据}|
|第二步|{app首部\|用户数据}|
|第三步|{TCP首部\|app首部\|用户数据}|
|第四步|{IP首部\|TCP首部\|app首部\|用户数据}|
|第五步|{以太网首部（14字节 其中包含协议类型）\|IP首部（20字节）\|TCP首部（20字节）\|app首部\|用户数据\|以太网尾部（4字节）}|

2. 以太网帧的大小为46~1500字节

### 分用
1. 分用就是对主机在接收到客户机封装的数据帧的一个逆向过程
|步骤：||
|:----:|:----:|
|第一步|解析以太网数据帧的首部数据，获取当前协议类型（假如是ip协议）然后将去掉首部的数据分配给ip协议|
|第二步|IP协议程序解析IP协议首部，获得IP协议值（假如是TCP）根据IP协议值将去掉IP首部的数据分配给TCP协议|
|第三步|{TCP会去掉TCP的首部，将数据分用给应用层（根据端口号决定）|app首部|用户数据}|

### 端口号

1. 众所周知端口（well known ports）：从0到1023，这些端口由IANA分配和控制他们紧密绑定与一些服务。通常这些端口的通讯明确表明某种服务的协议。例如：21端口为ftp服务端口。

2. 注册端口（register ports）：从1024到49151。这些端口不受IANA控制，但IANA登记并提供使用清单。他们松散的绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它的目的。例如：1443 Microsoft SQL服务器端口

3. 动态或私有端口（Dynamic or Private Ports）：从49152到65535 IANA不管这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。

4. IP不能标识一个主机上的应用程序，数据到达主机的时候如何区分数分用给那个应用程序呢？那这个时候就需要端口号来标识不同的应用程序。

# 第二章
## TCP/PI基础（二）

### 最大传输单元（MTU）/路径MTU

1. 以太网和IEEE 802.3对数据帧的长度都有限制，其最大值分别是1500和1492字节，将这个限制称做最大传输单元（MTU，Maximum Transmission Unit）。

2. 如果IP层一个数据报要传，而且数据长度比链路层的MTU还大，那么IP层就要进行分片（fragmentation），把数据报分成若干片，这样每一片都小于MTU。


3. 当网络上的两台主机相互通信时，两台主机要经过多个网络，每个网络可能有不同的MTU，其中两台通信主机路径中最小MTU被称作MTU。

### 以太网帧格式

1. 以太网封装(RFC 894):

+ {目的地址[^6] |  源地址[^6]  |  类型[^2]| 数据[^46~1500] |CRC[^4]} 

+ {类型[^2] (0800) | IP数据报[^46~1500]}

+ {类型[^2] 0806 | ARP请求/应答[^28] | PAD[^18]}

+ {类型[^2] 8035 | RARP请求/应答[^28] | PAD[^18]}    

2. 用于以太网的ARP请求或应答分组格式

+ {以太网目的地址[^6]  | 以太网源地址[^6]  | 帧类型 [^2] | 硬件类型[^2] | 协议类型[^2] | 硬件地址长度[^1] | 协议地址长度[^1] | op[^2] | 发送端以太网地址[^6] | 发送端IP地址[^4] | 目的以太网地址[^6] | 目的IP地址[^4] }

  { |<-------   以太网首部   --------->|<----------------------------------------------------   28字节ARP请求应答   ------------------------------------------------------>| }

3. 对于链路层来说它只识别物理地址（mac地址），IP可以理解为是一个逻辑地址在IP地址转换成mac地址的过程叫做地址解析
4. IP---->MAC 地址解析(ARP协议)、MAC---->IP 反向地址解析(RARP协议)
5. 

### ICMP

1. ICMP协议用于传递差错信息、时间、回显、网络信息等控制数据

2. ICMP报文在IP数据报中的位置:

   { |    IP头部 [^20] |  ICMP报文 | }

   { |<-----  IP数据报文  ------>| }

3. ICMP 报文的数据格式

{ |      类型[^8]       |        代码[^8]         |        校验和[^16]     | }

{|数据部分[^(8+8+16)*N],此部分不同的类型和代码格式不同|}

4. ICMP协议类型码：

   | 类型 | 代码 |              描述               | 查询 | 差错 |
   | :--: | :--: | :-----------------------------: | :--: | :--: |
   |  0   |  0   |      回显应答（ping 应答）      |  *   |      |
   |  3   |      |           目的不可达            |      |  *   |
   |      |  0   |           网络不可达            |      |  *   |
   |      |  1   |           主机不可达            |      |  *   |
   |      |  2   |           协议不可达            |      |  *   |
   |      |  3   |           端口不可达            |      |  *   |
   |      |  4   | 需要进行分片但是设置了不分片bit |      |  *   |
   |      |  5   |          源站选路失败           |      |  *   |
   |      |  6   |         目的网络不认识          |      |  *   |
   |      |  7   |         目的主机不认识          |      |  *   |
   |      |  8   |    源主机被隔离（作废不用）     |      |  *   |
   |      |  9   |       目的网络被强制禁止        |      |  *   |
   |      |  10  |       目的主机被强制禁止        |      |  *   |
   |      |  11  |   由于服务类型TOS，网络不可达   |      |  *   |
   |      |  12  |   由于服务类型TOS，主机不可达   |      |  *   |
   |      |  13  |     由于过滤通信被强制禁止      |      |  *   |
   |      |  14  |            主机越权             |      |  *   |
   |      |  15  |         优选权终止生效          |      |  *   |
   |  4   |      |           源端被关闭            |      |  *   |
   |  5  |      |           重定向            |      |  *   |
   |  8  |   0   |           对网络重定向            |      |  *  |
   |    |   2   |           对主机重定向            |      |  *  |
   |    |   3   |           对服务类型和网络重定向            |      | *   |
   |  9  |   0   |           路由器通告            |      | *   |
   |  10  |   0   |           路由器请求           |   *   |    |
   |  11  |   0   |           超时，传输期间生存在时间为0           |  *    |    |
   |  11  |   1  |           超时，在数据报组装期间生存时间为0         |   *   |    |
   |  12  |   0  |           参数问题，坏的ip首部（包括各种差错）        |      | *   |
   |  12  |   1  |           参数问题，缺少必须的选项        |      | *   |
   |  13  |   0  |           时间戳请求       |      | *   |
   |  14  |   0  |           时间戳应答        |      | *   |
   |  15  |   0  |           信息请求（作废不用）        |   *   |    |
   |  16  |   0  |          信息应答（作废不用）        |   *   |    |
   |  17  |   0  |          地址掩码请求        |   *   |    |
   |  18  |   0  |          地址应答请求        |   *   |   |


### ARP-地址解析协议
1. 地址解析协议步骤

     [^1] 我需要ip地址a的mac地址
    [^2]ARP缓存区中有映射吗？
    [^3]没有，发出广播请求包（每台主机都收到并打开上传到网络层）
    [^4]主机判断是自己的IP地址回复ARP请求，把源的MAC加入到ARP缓冲区，源收到回复包并往ARP缓冲区中加入条目，源IP按目标MAC发送数据并等回应
    [^5]主机判断不是是自己的IP地址丢弃

2. 数据在网络中的传输过程

+ 步骤a：应用程序ping会判断发送的是主机名称还是ip地址，调用函数gethostbyname()解析主机B，将主机名换成一个32位的IP地址。这个过程叫做DNS域名解析

+ 步骤b：ping应用程序向IP地址发送一个ICMP的ECHO包

+ 步骤c：将目标主机的IP地址转换为48位的硬件地址，在局域网内发送ARP请求广播，查找主句B的硬件地址。

+ 步骤d：主机B的ARP协议层接收到主机A的ARP请求后，将本机的硬件地址填充到应答包，发送ARP应答到主机A。

+ 步骤e：发送ICMP数据包到主机B

+ 步骤f：主机B接收到主机A的ICMP请求包后发送响应包

+ 步骤g：主机A收到主机B的ICMP响应包

  



### RARP-反向地址解析协议

1. 反向地址解析协议主要用于无盘工作站，主机通过自己的MAC地址使用RARP协议，请求RARP服务器从而获取自己的IP地址。



# 第三章

## IP数据报格式

1. IP数据报格式

| 版本[^4] | 首部长度[^4] | 服务器类型[^8] | 总长度[^16]  |;

|    标示[^16]    |    标志位[^8]      |    偏移位[^13]            |;

|生成时间TIL[^8] |   协议类型[^8]   |  头部校验和[^16]    |;

|                           源IP地址[^32]                                 |;

|                           目标地址[^32]                                 |;

|      选项位[^32]           |                     填充                  |;//4个字节的整数倍不够就填充0

|                              数据                                           |；



2. 版本：IP协议版本号，长度为4个bit，IPV4此字段为4，IPV6此字段为6

3. 首部长度：以32位的字为单位，该字段长度为4位，最大值位15，所以首部长度最大为60个字节

4. 服务类型（TOS）：长度为8位，此字段包含3位的优先权（现已忽略），4位服务类型子字段和1位的保留位（必须置0）。4位的服务类型分别为最小延迟（D）、最大吞吐量（T）、最高可靠性（R）、最小费用（F）

   

   | 字段 | 优先权 | D    | T      | R      | F    | 保留   |
   | ---- | ------ | ---- | ------ | ------ | ---- | ------ |
   | 长度 | 3位    | 1位  | 1位    | 1位    | 1位  | 1位    |
   | 含义 | 优先级 | 延迟 | 吞吐量 | 可靠性 | 费用 | 未使用 |

5. 总长度：该字段长度为16位，以字节为单位，该字段长度包含IP的头部和数据部分。IP数据报最大可达65535个字节。

6. 标识：16位标识，用来标识一个IP包，每发送一个此值加一

7. 标志与片偏移：

   + 3位标识其中第一位不使用，每二位DF（Don‘t Fragment），该位如果为1，如果传输的数据报大于最大传输单元，该数据包会被丢弃，并发送一个ICMP差错报文。第三位MF（More Fragament）标示是否有更多的分片，该位为1，说明后续有分片。最后一片MF 为 0
   + IP分片后每一分组都具有自己的首部，但是片偏移值不同，通过片偏移值接收端可以重新组装IP包。

8. TTL(Time to live) 表示数据最多可以经过的路由器数量,数据报每经过一个路由器TTL减一，减为0的时候丢弃，并发送ICMP报文通知源主机。TTL可以避免数据报不断的在路由器之间不断循环。

9. 协议类型：标示IP层上承载的是哪个高级协议。在封装与分组的过程中，协议栈知道交给哪个层的协议处理。1 ICMP 、2 IGMP 、6 TCP 、 17 UDP

10. 头部校验和：保证数据报头部数据的完整性，但校验不包括数据部分。这样的目的有二：1. 所有将数据封装在IP数据包中的高层协议均含有覆盖整个数据的校验和，因此IP数据报没有必要再对其所承载的数据部分进行校验。2. 每经过一个路由器，IP数据报的头部要发生改变，而数据部分不变，这样只对发生改变的头部进行校验，当然不能浪费太多时间。为了减少计算时间，一般不用CRC校验码，而是采用更简单的网际校验和。

11. 源IP地址：发送数据的主机IP地址

12. 目的IP地址：接收数据的主机IP地址

13. 选项与填充：（选项为4字节整数倍，否则用0填充）

    + 安全和处理限制
    + 路径记录：记录所经历路由器的IP地址
    + 时间戳：记录所经历路由器IP地址和时间
    + 宽松源站路由：指定数据报文必须经历的IP地址，可以经过没有指定的IP地址
    + 严格的源站路由：指定报文必须经历的IP地址，不能经过没有指定的IP地址

## 网际校验和

1. 网际校验和，英文全称（Internet Checksum）
2. 发送方对要发送的数据划分为许多16位字序列(如果数据的字节数为奇数,则在末尾补一字节的0凑成偶数)对这些序列反码求和,便得到校验和。
3. 如果数据在传输中没有发生任何差错，那么接收方计算校验和的结果应该全为1，如果结果不全为1即校验和错误。

## 路由

1. 搜索匹配的主机地址
2. 搜索网络地址
3. 搜索默认表项

# 第四章 tcp/ip基础
## tcp特点
1. 基于字节流
2. 面向连接
3. 可靠传输
4. 缓冲输出
5. 全双工
6. 流量控制

## TCP报文格式
1. 源端口号与目的端口号：源端口号加上目的端口号以及ip头部的源ip地址和目的ip地址唯一确定一个tcp连接。
2. 序号：序号表示在这个报文中的第一个数据字节序号。
3. 确认号：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号。
4. 头部长度：4位，tcp头部最多60个字节
5. 保留位：6位，必须为0
6. 6个标志位
   + URG：紧急指针有效
   + ACK：确认序列号有效
   + PSH：接收方应该尽快把这个数据报文段交给应用层
   + RST：连接重置
   + SYN：同步序号用来发起一个连接
   + FIN：表示将要终止一个连接
   
7. 窗口大小：通过窗口大小来达到流量控制。
8. 校验和：对tcp头与数据进行校验
9. 紧急指针：是一个正的偏移量，与序列号字段中的值相加表示紧急数据最后一个字节的序列号。tcp的紧急方式是发送端向另一端发送紧急数据的一种方式。
10. 选项与填充（选项为4字节整数倍，否则用0填充）：最常见的可选字段是最长报文大小MSS（Maximum Segment Size），每个连接方通常在通信的第一个报文段中指明这个选项，它指明本端所能接收的最大长度的报文段。该段如果不设置，默认为536（20+20+536=576字节的ip数据报）

## 连接建立三次握手
## 断开连接四次挥手

## TCP如何保证可靠性
+ 应用数据被分割成TCP人为最适合发送的数据块，称为段传递给IP层。
+ 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发一个报文段。
+ 当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。
+ TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到断的检验和有差错，TCP将丢弃这个报文段并且不确认（导致对方超时重传）
+ TCP承载于IP数据报来传输，而IP数据报的到达可能会失序，因此tcp报文的到达也可能会失序。TCP将对收到的数据进行重排。
+ IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
+ TCP还能提供流量控制。TCP连接的每一方都有一定大小的缓存空间

# 第五章（TCP/IP基础）
## 滑动窗口协议
+ 通告接收窗口（rwnd）：预防应用发送的数据超过接收方的缓冲区。接收方使用的流量控制
+ 拥塞窗口（cwnd）：预防应用程序发送的数据超过网络所能承受的能力。发送方使用的流量控制
+ 发送窗口取通告接收窗口和拥塞窗口中较小的那一个
+ 慢启动阀值（ssthresh：slow start threshold）
+ 慢启动阶段：cwnd从1开始指数增长直到ssthresh
+ 拥塞避免阶段：cwnd按线性增长，直到拥塞，将cwnd=1，ssthresh减半

## UDP特点
+ 无连接
+ 不可靠
+ 一般情况下UDP更高效

## UDP报文格式

# 第六章（socket编程一）

## 什么是socket
+ socket可以看做是用户进程与内核网络协议栈的编程接口
+ socket不仅可以用于本机的进程通信，还可以用于网络上不同主机的进程间通信

## IPv4套接口地址结构
1.  IPv4套接口地址结构通常也称为“网际套接字地址结构”，它以“sockaddr_in”命名，定义在<netinet/in.h>头文件中
struct sockadd_in{
uint8_t sin_len;
sa_family sin_family;
in_port_t sin_port;
struct in_add sin_addr;
char sin_zero[8];
}
+ sin_len:整个sockadd_in结构体的长度，在4.3BSD-Reno版本之前的第一个成员是sin_family.
+ sin_family:指定该地址家族，在这里必须设置为AF_INET
+ sin_port :端口
+ sin_addr:IPv4的地址
+ sin_zero:暂不使用，一般将其设置为0

2. 通用地址结构用来指定与套接字关联的地址
struct sockaddr{
uint_8 sin_len;
sa_family_t sin_family
char sa_data[14];
}
+ sin_len:整个sockaddr结构的长度
+ sin_family:指定该地址家族
+ sa_data:由sin_family决定它的形式


## 网络字节序
### 字节序
+ 大端字节序（Big Endian）：最高有效位（MSB：Most Significant Bit）存储于最低内存地址处，最低有效位（LSB：Lowest Signigicant Bit）存储于最高内存地址处
+ 小端字节序（Big Endian）：最高有效位（MSB：Most Significant Bit）存储于最高内存地址处，最低有效位（LSB：Lowest Signigicant Bit）存储于最低内存地址处
+ 主机字节序：不同的主机有不同的字节序，如x86为小端字节序，Motorola 6800为大端字节序，ARM字节序是可配置的。
+ 网络字节序: 网络字节序规定为大端字节序

## 字节序转换函数
+ uint32_t htonl(uint32_t hostlong);
+ uint16_t htons(uint16_t hostshort);
+ uint32_t ntohl(uint32_t netlong);
+ uint16_t ntohs(uint16_t netshort)
+ 说明：在上述函数中，h代表host；n代表network s代表short；l代表long

## 地址转换函数
+ #include<netinet/in.h>
+ #include<arpa/inet.h>
+ int inet_aton(const char *cp,struct in_addr *inp);
+ in_addr_t inet_addr(const char *cp);
+ char *inet_ntoa(struct in_addr in);
## 套接字类型
+ 流式套接字(sock_stream）:提供面向连接的，可靠的数据传输服务，数据无差错，无重复的发送，且按顺序发送。
+ 数据报式套接字（sock_dgram）:提供无连接服务。不提供无差错保证，数据可能丢失或者重复，并且接收顺序混乱。
+ 原始套接字（sock_raw）

# 第七章（socket编程二）


